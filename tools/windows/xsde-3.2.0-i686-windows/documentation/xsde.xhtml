<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>XSD/e 3.2.0 Compiler Command Line Manual</title>

  <meta name="copyright" content="&copy; 2005-2011 Code Synthesis Tools CC"/>
  <meta name="keywords" content="xsd,xml,schema,c++,mapping,data,binding,code,generator,manual,man,page"/>
  <meta name="description" content="XSD/e Compiler Command Line Manual"/>

  <link rel="stylesheet" type="text/css" href="default.css" />

<style type="text/css">

  #synopsis {
    list-style-type:  none;
  }

  #synopsis li {
    padding-top      : 0.0em;
    padding-bottom   : 0.0em;
  }

  #commands dt {
    padding-top      : 0.4em;
  }

  #commands dd {
    padding-bottom   : 0.4em;
    padding-left     : 2em;
  }

  .options dt {
    padding-top      : 0.4em;
  }

  .options dd {
    padding-top      : 0.1em;
    padding-bottom   : 0.4em;
    padding-left     : 1.4em;
  }

</style>
</head>

<body>
<div id="container">
  <div id="content">

  <h1>NAME</h1>

  <p>xsde - W3C XML Schema to C++ Compiler for Embedded Systems</p>

  <h1>SYNOPSIS</h1>

  <dl id="synopsis">
    <dt><code><b>xsde</b> <i>command</i> [<i>options</i>] <i>file</i> [<i>file</i> ...]</code></dt>
    <dt><code><b>xsde help</b> [<i>command</i>]</code></dt>
    <dt><code><b>xsde version</b></code></dt>
  </dl>

  <h1>DESCRIPTION</h1>

  <p><code><b>xsde</b></code> generates vocabulary-specific, statically-typed
  C++ mapping from W3C XML Schema definitions. Particular mapping to
  produce is selected by a <code><i>command</i></code>. Each mapping has
  a number of mapping-specific <code><i>options</i></code> that should
  appear, if any, after the <code><i>command</i></code>. Input files should
  be W3C XML Schema definitions. The exact set of the generated files
  depends on the selected mapping and options.</p>

  <h1>COMMANDS</h1>

  <dl id="commands">
    <dt><code><b>cxx-hybrid</b></code></dt>
    <dd>Generate the Embedded C++/Hybrid mapping. For each input file in the
        form <code><b>name.xsd</b></code> the following C++ files are generated:
        <code><b>name.hxx</b></code> (object model header file),
        <code><b>name.ixx</b></code> (object model inline file, generated only
          if the <code><b>--generate-inline</b></code> option is specified),
	<code><b>name.cxx</b></code> (object model source file), and
        <code><b>name-fwd.hxx</b></code> (object model forward declaration
          file, generated only if the <code><b>--generate-forward</b></code>
          option is specified).

        <p>If the <code><b>--generate-parser</b></code> option is specified,
        the Embedded C++/Parser mapping is invoked and the
        <code><b>name-pskel.hxx</b></code>,
        <code><b>name-pskel.ixx</b></code>, and
	<code><b>name-pskel.cxx</b></code> parser skeleton files are
        generated, as described below. Additionally, the following parser
        implementation files are generated:
        <code><b>name-pimpl.hxx</b></code> (parser implementation header
        file) and
        <code><b>name-pimpl.cxx</b></code> (parser implementation source
        file).</p>

        <p>If the <code><b>--generate-serializer</b></code> option is
        specified, the Embedded C++/Serializer mapping is invoked and the
        <code><b>name-sskel.hxx</b></code>,
        <code><b>name-sskel.ixx</b></code>, and
	<code><b>name-sskel.cxx</b></code> serializer skeleton files are
        generated, as described below. Additionally, the following serializer
        implementation files are generated:
        <code><b>name-simpl.hxx</b></code> (serializer implementation header
        file) and
        <code><b>name-simpl.cxx</b></code> (serializer implementation source
        file).</p>
    </dd>

    <dt><code><b>cxx-parser</b></code></dt>
    <dd>Generate the Embedded C++/Parser mapping. For each input file in the
        form <code><b>name.xsd</b></code> the following C++ files are generated:
        <code><b>name-pskel.hxx</b></code> (parser skeleton header file),
        <code><b>name-pskel.ixx</b></code> (parser skeleton inline file,
          generated only if the <code><b>--generate-inline</b></code>
          option is specified), and
	<code><b>name-pskel.cxx</b></code> (parser skeleton source file).
        If the <code><b>--generate-noop-impl</b></code> or
        <code><b>--generate-print-impl</b></code> option is specified,
        the following additional sample implementation files are generated:
        <code><b>name-pimpl.hxx</b></code> (parser implementation header
        file) and
        <code><b>name-pimpl.cxx</b></code> (parser implementation source
        file). If the <code><b>--generate-test-driver</b></code> option
        is specified, the additional <code><b>name-pdriver.cxx</b></code>
        test driver file is generated.</dd>

    <dt><code><b>cxx-serializer</b></code></dt>
    <dd>Generate the Embedded C++/Serializer mapping. For each input file
        in the form <code><b>name.xsd</b></code> the following C++ files
        are generated: <code><b>name-sskel.hxx</b></code> (serializer
        skeleton header file), <code><b>name-sskel.ixx</b></code> (serializer
        skeleton inline file, generated only if the
        <code><b>--generate-inline</b></code> option is specified), and
	<code><b>name-sskel.cxx</b></code> (serializer skeleton source file).
        If the <code><b>--generate-empty-impl</b></code> option is specified,
        the following additional sample implementation files are generated:
        <code><b>name-simpl.hxx</b></code> (serializer implementation header
        file) and <code><b>name-simpl.cxx</b></code> (serializer
        implementation source file). If the <code><b>--generate-test-driver</b></code>
        option is specified, the additional <code><b>name-sdriver.cxx</b></code>
        test driver file is generated.
    </dd>

    <dt><code><b>help</b></code></dt>
    <dd>Print usage information and exit. Use
      <p><code><b>xsde help</b> <i>command</i></code></p>
      for command-specific help.
    </dd>

    <dt><code><b>version</b></code></dt>
    <dd>Print version and exit.</dd>
  </dl>

  <h1>OPTIONS</h1>

  <p>Command-specific <code><i>options</i></code>, if any, should appear
  after the corresponding <code><i>command</i></code>.</p>

  <h2>COMMON OPTIONS</h2>

  <dl class="options">
    <dt><code><b>--output-dir</b> <i>dir</i></code></dt>
    <dd>Write generated files to <code><i>dir</i></code> instead of
      the current directory.</dd>

    <dt><code><b>--char-encoding</b> <i>enc</i></code></dt>
    <dd>Specify the application character encoding. Valid values are
        <code><b>utf8</b></code> (default) and <code><b>iso8859-1</b></code>.
        Note that this encoding is not the same as the XML document encoding
        that is being parsed or serialized. Rather, it is the encoding that
        is used inside the application. When an XML document is parsed, the
        character data is automatically converted to the application encoding.
        Similarly, when an XML document is serialized, the data in the
        application encoding is automatically converted to the resulting
        document encoding.</dd>

    <dt><code><b>--no-stl</b></code></dt>
    <dd>Generate code that does not use the Standard Template Library
        (STL).</dd>

    <dt><code><b>--no-iostream</b></code></dt>
    <dd>Generate code that does not use the standard input/output
        stream library (iostream).</dd>

    <dt><code><b>--no-exceptions</b></code></dt>
    <dd>Generate code that does not use C++ exceptions.</dd>

    <dt><code><b>--no-long-long</b></code></dt>
    <dd>Generate code that does not use the <code><b>long long</b></code>
        and <code><b>unsigned long long</b></code> types. The
        64 bit <code><b>long</b></code> and <code><b>unsignedLong</b></code>
        built-in XML Schema types are then mapped to <code><b>long</b></code>
        and <code><b>unsigned long</b></code>.</dd>

    <dt><code><b>--custom-allocator</b></code></dt>
    <dd>Generate code that performs memory management using custom allocator
        functions provided by your application instead of the standard
        operator new/delete.</dd>

    <dt><code><b>--generate-inline</b></code></dt>
    <dd>Generate simple functions inline. This option triggers creation
      of the inline file.</dd>

    <dt><code><b>--namespace-map</b> <i>xns</i><b>=</b><i>cns</i></code></dt>
    <dd>Map XML Schema namespace <i>xns</i> to C++ namespace <i>cns</i>.
        Repeat this option to specify mapping for more than one XML Schema
        namespace. For example, the following option:

        <p><code><b>--namespace-map http://example.com/foo/bar=foo::bar</b></code></p>

        <p>will map the <code><b>http://example.com/foo/bar</b></code>
           XML Schema namespace to the <code><b>foo::bar</b></code> C++
           namespace.</p>
    </dd>

    <dt><code><b>--namespace-regex</b> <i>regex</i></code></dt>
    <dd>Add <code><i>regex</i></code> to the list of regular expressions
      used to translate XML Schema namespace names to C++ namespace
      names. <code><i>regex</i></code> is a perl-like regular expression in
      the form <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      Any character can be used as a delimiter instead of <code><b>/</b></code>.
      Escaping of the delimiter character in <code><i>pattern</i></code> or
      <code><i>replacement</i></code> is not supported.

      <p>All the regular expressions are pushed into a stack with the last
        specified expression considered first. The first match that
        succeeds is used. Regular expressions are applied to a string
        in the form</p>

      <p><code><i>filename</i> <i>namespace</i></code></p>

      <p>For example, if you have file <code><b>hello.xsd</b></code>
        with namespace <code><b>http://example.com/hello</b></code> and you run
        <code><b>xsd</b></code> on this file, then the string in question
        will be:</p>

      <p><code><b>hello.xsd. http://example.com/hello</b></code></p>

      <p>For the built-in XML Schema namespace the string is:</p>

      <p><code><b>XMLSchema.xsd http://www.w3.org/2001/XMLSchema</b></code></p>

      <p>The following three steps are performed for each regular expression
        until the match is found:</p>

      <ol>
        <li>The expression is applied and if the result is empty the
          next expression is considered.</li>

        <li>All <code><b>/</b></code> are replaced with
          <code><b>::</b></code>.</li>

        <li>The result is verified to be a valid C++ scope name (e.g.,
          <code><b>foo::bar</b></code>). If this test succeeds, the
          result is used as a C++ namespace name.</li>
      </ol>

      <p>As an example, the following expression maps XML  Schema
        namespaces  in  the  form
        <code><b>http://example.com/foo/bar</b></code> to C++
        namespaces in the form <code><b>foo::bar</b></code>:</p>

      <p><code><b>%.* http://example.com/(.+)%$1%</b></code></p>

      <p>See also the REGEX AND SHELL QUOTING section below.</p>
    </dd>

    <dt><code><b>--namespace-regex-trace</b></code></dt>
    <dd>Trace the process of applying regular expressions specified with
        the <code><b>--namespace-regex</b></code> option. Use this option
        to find out why your regular expressions don't do what you expected
        them to do.
    </dd>

    <!-- Reserved names -->

    <dt><code><b>--reserved-name</b> <i>name</i>[<b>=</b><i>rep</i>]</code></dt>
    <dd>Add <code><i>name</i></code> to the list of names that should not
        be used as identifiers. The name can optionally be followed by
        <code><b>=</b></code> and the replacement name that should be
        used instead. All the C++ keywords are already in this list.
    </dd>

    <dt><code><b>--include-with-brackets</b></code></dt>
    <dd>Use angle brackets (&lt;&gt;) instead of quotes ("") in
        generated <code><b>#include</b></code> directives.
    </dd>

    <dt><code><b>--include-prefix</b> <i>prefix</i></code></dt>
    <dd>Add <code><i>prefix</i></code> to generated <code><b>#include</b></code>
        directive paths.

        <p>For example, if you had the following import element in your
           schema</p>

        <p><code><b>&lt;import namespace="..." schemaLocation="base.xsd"/&gt;</b></code></p>

        <p>and compiled this fragment with <code><b>--include-prefix schemas/</b></code>,
           then the include directive in the generated code would be:</p>

        <p><code><b>#include "schemas/base.hxx"</b></code></p>
    </dd>

    <dt><code><b>--include-regex</b> <i>regex</i></code></dt>
    <dd>Add <code><i>regex</i></code> to the list of regular expressions
      used to transform <code><b>#include</b></code> directive paths.
      <code><i>regex</i></code> is a perl-like regular expression in
      the form <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      Any character can be used as a delimiter instead of <code><b>/</b></code>.
      Escaping of the delimiter character in <code><i>pattern</i></code> or
      <code><i>replacement</i></code> is not supported.

      <p>All the regular expressions are pushed into a stack with the last
        specified expression considered first. The first match that
        succeeds is used.</p>

      <p>As an example, the following expression transforms paths
        in the form <code><b>schemas/foo/bar</b></code> to paths
        in the form <code><b>generated/foo/bar</b></code>:</p>

      <p><code><b>%schemas/(.+)%generated/$1%</b></code></p>

      <p>See also the REGEX AND SHELL QUOTING section below.</p>
    </dd>

    <dt><code><b>--include-regex-trace</b></code></dt>
    <dd>Trace the process of applying regular expressions specified with
        the <code><b>--include-regex</b></code> option. Use this option
        to find out why your regular expressions don't do what you expected
        them to do.
    </dd>

    <dt><code><b>--guard-prefix</b> <i>prefix</i></code></dt>
    <dd>Add <code><i>prefix</i></code> to generated header inclusion guards.
        The prefix is transformed to upper case and characters that are
        illegal in a preprocessor macro name are replaced with underscores.
        If this option is not specified then the directory part of the
        input schema file is used as a prefix.
    </dd>

    <dt><code><b>--hxx-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the default
      <code><b>.hxx</b></code> to construct the name of the header file.
      Note that this suffix is also used to construct names for
      included/imported schemas.
    </dd>

    <dt><code><b>--ixx-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the default
      <code><b>.ixx</b></code> to construct the name of the inline file.
    </dd>

    <dt><code><b>--cxx-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the default
      <code><b>.cxx</b></code> to construct the name of the source file.
    </dd>

    <dt><code><b>--fwd-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the default
      <code><b>-fwd.hxx</b></code> to construct the name of the forward
      declaration file (C++/Hybrid mapping only).
    </dd>

    <dt><code><b>--hxx-regex</b> <i>regex</i></code></dt>
    <dd>Use the provided expression to construct the name of the header
      file. <code><i>regex</i></code> is a perl-like regular expression
      in the form
      <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      This expression is also used to construct names for included/imported
      schemas.

      <p>
      For the C++/Hybrid mapping, the <code><i>regex</i></code> argument
      can be optionally prefixed with a file key in the form
      <code><i>key</i>=<i>regex</i></code>. The valid values for
      <code><i>key</i></code> are <code><b>pskel</b></code> (parser
      skeleton files), <code><b>pimpl</b></code> (parser implementation
      files), <code><b>sskel</b></code> (serializer skeleton files),
      <code><b>simpl</b></code> (serializer implementation files),
      and <code><b>*</b></code> (all files). If <code><i>key</i></code>
      is empty or not present then the expression is used for the
      object model files only.
      </p>

      <p>See also the REGEX AND SHELL QUOTING section below.</p>
    </dd>

    <dt><code><b>--ixx-regex</b> <i>regex</i></code></dt>
    <dd>Use the provided expression to construct the name of the inline
      file. <code><i>regex</i></code> is a perl-like regular expression
      in the form
      <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      For the C++/Hybrid mapping, the <code><i>regex</i></code> argument
      can be optionally prefixed with a file key. See the
      <code><b>--hxx-regex</b></code> option for details.
      See also the REGEX AND SHELL QUOTING section below.
    </dd>

    <dt><code><b>--cxx-regex</b> <i>regex</i></code></dt>
    <dd>Use the provided expression to construct the name of the source
      file. <code><i>regex</i></code> is a perl-like regular expression
      in the form
      <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      For the C++/Hybrid mapping, the <code><i>regex</i></code> argument
      can be optionally prefixed with a file key. See the
      <code><b>--hxx-regex</b></code> option for details.
      See also the REGEX AND SHELL QUOTING section below.
    </dd>

    <dt><code><b>--fwd-regex</b> <i>regex</i></code></dt>
    <dd>Use the provided expression to construct the name of the forward
      declaration file (C++/Hybrid mapping only). <code><i>regex</i></code>
      is a perl-like regular expression in the form
      <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      See also the REGEX AND SHELL QUOTING section below.
    </dd>

    <!-- prologue options -->

    <dt><code><b>--hxx-prologue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the beginning of the header file.

      <p>
      For the C++/Hybrid mapping, the <code><i>text</i></code> argument
      can be optionally prefixed with a file key in the form
      <code><i>key</i>=<i>text</i></code>. The valid values for
      <code><i>key</i></code> are <code><b>pskel</b></code> (parser
      skeleton files), <code><b>pimpl</b></code> (parser implementation
      files), <code><b>sskel</b></code> (serializer skeleton files),
      <code><b>simpl</b></code> (serializer implementation files),
      and <code><b>*</b></code> (all files). If <code><i>key</i></code>
      is empty or not present then the text is used for the
      object model files only.
      </p>

    </dd>

    <dt><code><b>--ixx-prologue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the beginning of the inline file.
        For the C++/Hybrid mapping, the <code><i>text</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue</b></code> option for details.
    </dd>

    <dt><code><b>--cxx-prologue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the beginning of the source file.
        For the C++/Hybrid mapping, the <code><i>text</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue</b></code> option for details.
    </dd>

    <dt><code><b>--fwd-prologue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the beginning of the forward
        declaration file (C++/Hybrid mapping only).
    </dd>

    <dt><code><b>--prologue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the beginning of each generated
        file for which there is no file-specific prologue.
        For the C++/Hybrid mapping, the <code><i>text</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue</b></code> option for details.
    </dd>

    <!-- epilogue options -->

    <dt><code><b>--hxx-epilogue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the end of the header file.
        For the C++/Hybrid mapping, the <code><i>text</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue</b></code> option for details.
    </dd>

    <dt><code><b>--ixx-epilogue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the end of the inline file.
        For the C++/Hybrid mapping, the <code><i>text</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue</b></code> option for details.
    </dd>

    <dt><code><b>--cxx-epilogue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the end of the source file.
        For the C++/Hybrid mapping, the <code><i>text</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue</b></code> option for details.
    </dd>

    <dt><code><b>--fwd-epilogue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the end of the forward
        declaration file (C++/Hybrid mapping only).
    </dd>

    <dt><code><b>--epilogue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the end of each generated
        file for which there is no file-specific epilogue.
        For the C++/Hybrid mapping, the <code><i>text</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue</b></code> option for details.
    </dd>

    <!-- prologue file options -->

    <dt><code><b>--hxx-prologue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the beginning
      of the header file.

      <p>
      For the C++/Hybrid mapping, the <code><i>file</i></code> argument
      can be optionally prefixed with a file key in the form
      <code><i>key</i>=<i>file</i></code>. The valid values for
      <code><i>key</i></code> are <code><b>pskel</b></code> (parser
      skeleton files), <code><b>pimpl</b></code> (parser implementation
      files), <code><b>sskel</b></code> (serializer skeleton files),
      <code><b>simpl</b></code> (serializer implementation files),
      and <code><b>*</b></code> (all files). If <code><i>key</i></code>
      is empty or not present then the file is used for the
      object model files only.
      </p>
    </dd>

    <dt><code><b>--ixx-prologue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the beginning
        of the inline file.
        For the C++/Hybrid mapping, the <code><i>file</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue-file</b></code> option for details.
    </dd>

    <dt><code><b>--cxx-prologue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the beginning
        of the source file.
        For the C++/Hybrid mapping, the <code><i>file</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue-file</b></code> option for details.
    </dd>

    <dt><code><b>--fwd-prologue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the beginning
        of the forward declaration file (C++/Hybrid mapping only).
    </dd>

    <dt><code><b>--prologue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the beginning
        of each generated file for which there is no file-specific prologue
        file.
        For the C++/Hybrid mapping, the <code><i>file</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue-file</b></code> option for details.
    </dd>

    <!-- epilogue file options -->

    <dt><code><b>--hxx-epilogue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the end of the
        header file.
        For the C++/Hybrid mapping, the <code><i>file</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue-file</b></code> option for details.
    </dd>

    <dt><code><b>--ixx-epilogue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the end of the
        inline file.
        For the C++/Hybrid mapping, the <code><i>file</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue-file</b></code> option for details.
    </dd>

    <dt><code><b>--cxx-epilogue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the end of the
        source file.
        For the C++/Hybrid mapping, the <code><i>file</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue-file</b></code> option for details.
    </dd>

    <dt><code><b>--fwd-epilogue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the end of the
      forward declaration file (C++/Hybrid mapping only).
    </dd>

    <dt><code><b>--epilogue-file</b> <i>file</i></code></dt>
    <dd>Insert the content of the <code><i>file</i></code> at the end of each
        generated file for which there is no file-specific epilogue file.
        For the C++/Hybrid mapping, the <code><i>file</i></code> argument
        can be optionally prefixed with a file key. See the
        <code><b>--hxx-prologue-file</b></code> option for details.
    </dd>


    <dt><code><b>--disable-warning</b> <i>warn</i></code></dt>
    <dd>Disable printing warning with id <i>warn</i>. If <code><b>all</b></code>
        is specified for the warning id then all the warnings are disabled.
    </dd>

    <!-- misc options -->

    <dt><code><b>--show-sloc</b></code></dt>
    <dd>Show the number of generated physical source lines of code (SLOC).
    </dd>

    <dt><code><b>--sloc-limit</b> <i>num</i></code></dt>
    <dd>Check that the number of generated physical source lines of code
        (SLOC) does not exceed <code><i>num</i></code>.
    </dd>

    <dt><code><b>--options-file</b> <i>file</i></code></dt>
    <dd>Read additional options from <code><i>file</i></code>. Each option
        should appear on a separate line optionally followed by space and
        an argument. Empty lines and lines starting with <code><b>#</b></code>
        are ignored. The semantics of providing options in a
        file is equivalent to providing the same set of options in
        the same order in the command line at the point where the
        <code><b>--options-file</b></code> option is specified
        except that shell escaping and quoting is not required.
        Repeat this option to specify more than one options files.
    </dd>

    <dt><code><b>--proprietary-license</b></code></dt>
    <dd>Indicate that the generated code is licensed under a proprietary
        license instead of the GPL.
    </dd>

    <!-- Anonymous options. -->

    <dt><code><b>--preserve-anonymous</b></code></dt>
    <dd>Preserve anonymous types. By default anonymous types are
        automatically named with names derived from the enclosing
        elements/attributes. Because mappings implemented by this
        compiler require all types to be named, this option is only
        useful if you want to make sure your schemas don't have
        anonymous types.
    </dd>

    <dt><code><b>--show-anonymous</b></code></dt>
    <dd>Show elements and attributes that are of anonymous types.
        This option only makes sense together with the
        <code><b>--preserve-anonymous</b></code> option.
    </dd>

    <dt><code><b>--anonymous-regex</b> <i>regex</i></code></dt>
    <dd>Add <code><i>regex</i></code> to the list of regular expressions
      used to derive names for anonymous types from the enclosing
      attributes/elements. <code><i>regex</i></code> is a perl-like regular
      expression in the form
      <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      Any character can be used as a delimiter instead of <code><b>/</b></code>.
      Escaping of the delimiter character in <code><i>pattern</i></code> or
      <code><i>replacement</i></code> is not supported.

      <p>All the regular expressions are pushed into a stack with the last
        specified expression considered first. The first match that
        succeeds is used. Regular expressions are applied to a string
        in the form</p>

      <p><code><i>filename</i> <i>namespace</i> <i>xpath</i></code></p>

      <p>For instance:</p>

      <p><code><b>hello.xsd http://example.com/hello element</b></code></p>
      <p><code><b>hello.xsd http://example.com/hello type/element</b></code></p>

      <p>As an example, the following expression makes all the derived
         names start with capital letters. This could be useful when
         your naming convention requires type names to start with
         capital letters:</p>

      <p><code><b>%.* .* (.+/)*(.+)%\u$2%</b></code></p>

      <p>See also the REGEX AND SHELL QUOTING section below.</p>
    </dd>

    <dt><code><b>--anonymous-regex-trace</b></code></dt>
    <dd>Trace the process of applying regular expressions specified with
        the <code><b>--anonymous-regex</b></code> option. Use this option
        to find out why your regular expressions don't do what you expected
        them to do.
    </dd>

    <!-- Location mapping options. -->

    <dt><code><b>--location-map</b> <i>ol</i><b>=</b><i>nl</i></code></dt>
    <dd>Map the original schema location <i>ol</i> that is specified in
        the XML Schema include or import elements to new schema
        location <i>nl</i>. Repeat this option to map more than one
        schema location. For example, the following option maps the
        <code><b>http://example.com/foo.xsd</b></code> URL to the
        <code><b>foo.xsd</b></code> local file.

        <p><code><b>--location-map http://example.com/foo.xsd=foo.xsd</b></code></p>
    </dd>

    <dt><code><b>--location-regex</b> <i>regex</i></code></dt>
    <dd>Add <code><i>regex</i></code> to the list of regular expressions
      used to map schema locations that are specified in the XML Schema
      include or import elements. <code><i>regex</i></code> is a perl-like
      regular expression in the form
      <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      Any character can be used as a delimiter instead of <code><b>/</b></code>.
      Escaping of the delimiter character in <code><i>pattern</i></code> or
      <code><i>replacement</i></code> is not supported. All the regular
      expressions are pushed into a stack with the last specified
      expression considered first. The first match that succeeds is used.

      <p>For example, the following expression maps URL locations in the form
        <code><b>http://example.com/foo/bar.xsd</b></code> to local files
        in the form <code><b>bar.xsd</b></code>:</p>

      <p><code><b>%http://.+/(.+)%$1%</b></code></p>

      <p>See also the REGEX AND SHELL QUOTING section below.</p>
    </dd>

    <dt><code><b>--location-regex-trace</b></code></dt>
    <dd>Trace the process of applying regular expressions specified with
        the <code><b>--location-regex</b></code> option. Use this option
        to find out why your regular expressions don't do what you expected
        them to do.
    </dd>

    <!-- File-per-type compilation mode options. -->

    <dt><code><b>--file-per-type</b></code></dt>
    <dd>Generate a separate set of C++ files for each type defined in XML
        Schema. Note that in this mode you only need to compile the root
        schema(s) and the code will be generated for all included and
        imported schemas. This compilation mode is primarily useful when
        some of your schemas cannot be compiled separately or have cyclic
        dependencies which involve type inheritance. Other options related
        to this mode are:
        <code><b>--type-file-regex</b></code>,
        <code><b>--schema-file-regex</b></code>, and
	<code><b>--file-list</b></code>.
    </dd>


    <dt><code><b>--type-file-regex</b> <i>regex</i></code></dt>
    <dd>Add <code><i>regex</i></code> to the list of regular expressions
      used to translate type names to file names when the
      <code><b>--file-per-type</b></code> option is specified.
      <code><i>regex</i></code> is a perl-like regular expression in the form
      <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      Any character can be used as a delimiter instead of <code><b>/</b></code>.
      Escaping of the delimiter character in <code><i>pattern</i></code> or
      <code><i>replacement</i></code> is not supported. All the regular
      expressions are pushed into a stack with the last specified
      expression considered first. The first match that succeeds is used.
      Regular expressions are applied to a string in the form

      <p><code><i>namespace</i> <i>type-name</i></code></p>

      <p>For example, the following expression maps type <code><b>foo</b></code>
         that is defined in the <code><b>http://example.com/bar</b></code>
         namespace to file name <code><b>bar-foo</b></code>:</p>

      <p><code><b>%http://example.com/(.+) (.+)%$1-$2%</b></code></p>

      <p>See also the REGEX AND SHELL QUOTING section below.</p>
    </dd>

    <dt><code><b>--type-file-regex-trace</b></code></dt>
    <dd>Trace the process of applying regular expressions specified with
        the <code><b>--type-file-regex</b></code> option. Use this option
        to find out why your regular expressions don't do what you expected
        them to do.
    </dd>

    <dt><code><b>--schema-file-regex</b> <i>regex</i></code></dt>
    <dd>Add <code><i>regex</i></code> to the list of regular expressions
      used to translate schema file names when the
      <code><b>--file-per-type</b></code> option is specified.
      <code><i>regex</i></code> is a perl-like regular expression in the form
      <code><b>/</b><i>pattern</i><b>/</b><i>replacement</i><b>/</b></code>.
      Any character can be used as a delimiter instead of <code><b>/</b></code>.
      Escaping of the delimiter character in <code><i>pattern</i></code> or
      <code><i>replacement</i></code> is not supported. All the regular
      expressions are pushed into a stack with the last specified
      expression considered first. The first match that succeeds is used.
      Regular expressions are applied to the absolute filesystem path
      of a schema file and the result, including the directory part,
      if any, is used to derive the <code><b>#include</b></code> directive
      paths as well as the generated C++ file paths. This option, along
      with <code><b>--type-file-regex</b></code> are primarily used to
      place the generated files into subdirectories or to resolve file
      name conflicts.

      <p>For example, the following expression maps schema files in the
         <code><b>foo/1.0.0/</b></code> subdirectory to the files in
         the <code><b>foo/</b></code> subdirectory. As a result, the
         <code><b>#include</b></code> directive paths for such schemas
         will be in the <code><b>foo/schema.hxx</b></code> form and
         the generated C++ files will be placed into the
         <code><b>foo/</b></code> subdirectory:</p>

      <p><code><b>%.*/foo/1.0.0/(.+)%foo/$1%</b></code></p>

      <p>See also the REGEX AND SHELL QUOTING section below.</p>
    </dd>

    <dt><code><b>--schema-file-regex-trace</b></code></dt>
    <dd>Trace the process of applying regular expressions specified with
        the <code><b>--schema-file-regex</b></code> option. Use this option
        to find out why your regular expressions don't do what you expected
        them to do.
    </dd>

    <!-- File list options. -->

    <dt><code><b>--file-list</b> <i>file</i></code></dt>
    <dd>Write a list of generated C++ files to <code><i>file</i></code>.
        This option is primarily useful in the file-per-type compilation
        mode (<code><b>--file-per-type</b></code>) to create a list of
        generated C++ files, for example, as a makefile fragment.
    </dd>

    <dt><code><b>--file-list-prologue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the beginning of the file list.
        As a convenience, all occurrences of the \n character sequence in
        <code><i>text</i></code> are replaced with new lines. This option
        can, for example, be used to assign the generated file list to a
        makefile variable.
    </dd>

    <dt><code><b>--file-list-epilogue</b> <i>text</i></code></dt>
    <dd>Insert <code><i>text</i></code> at the end of the file list.
        As a convenience, all occurrences of the \n character sequence in
        <code><i>text</i></code> are replaced with new lines.
    </dd>

    <dt><code><b>--file-list-delim</b> <i>text</i></code></dt>
    <dd>Delimit file names written to the file list with
        <code><i>text</i></code>  instead of new lines. As a convenience,
        all occurrences of the \n character sequence in
        <code><i>text</i></code> are replaced with new lines.
    </dd>

  </dl>

  <h2>CXX-HYBRID COMMAND OPTIONS</h2>

  <dl class="options">
    <dt><code><b>--generate-parser</b></code></dt>
    <dd>Generate XML parsing code.</dd>

    <dt><code><b>--generate-serializer</b></code></dt>
    <dd>Generate XML serialization code.</dd>

    <dt><code><b>--generate-aggregate</b></code></dt>
    <dd>Generate parser/serializer aggregates for root elements and/or
        types. See also the <code><b>--root-element-*</b></code> and
        <code><b>--root-type</b></code> options.</dd>

    <dt><code><b>--suppress-validation</b></code></dt>
    <dd>Suppress the generation of validation code in parser and serializer.</dd>

    <dt><code><b>--suppress-parser-val</b></code></dt>
    <dd>Suppress the generation of validation code in parser.</dd>

    <dt><code><b>--suppress-serializer-val</b></code></dt>
    <dd>Suppress the generation of validation code in serializer.</dd>

    <dt><code><b>--omit-default-attributes</b></code></dt>
    <dd>Omit attributes with default and fixed values from serialized
        XML documents.</dd>

    <dt><code><b>--suppress-enum</b></code></dt>
    <dd>Suppress the generation of the XML Schema enumeration to C++
        enum mapping.</dd>

    <dt><code><b>--generate-clone</b></code></dt>
    <dd>Generate clone functions for variable-length types. These
        functions allow you to make dynamically-allocated copies of
        variable-length objects.</dd>

    <dt><code><b>--generate-detach</b></code></dt>
    <dd>Generate detach functions for elements and attributes of
        variable-length types. These functions, for example, allow
        you to move sub-trees in the object model either within the
        same tree or between different trees.</dd>

    <dt><code><b>--generate-insertion</b> <i>os</i></code></dt>
    <dd>Generate data representation stream insertion operators for
        the <code><i>os</i></code> output stream type. Repeat this
        option to specify more than one stream type. The special
        <code><b>CDR</b></code> and <code><b>XDR</b></code> arguments
        are recognized as ACE CDR and Sun RPC XDR stream types and
        the corresponding stream wrappers provided by the XSD/e runtime
        are automatically used. For custom stream types use the
        <code><b>--hxx-prologue*</b></code> options to include the
        necessary declarations.</dd>

    <dt><code><b>--generate-extraction</b> <i>is</i></code></dt>
    <dd>Generate data representation stream extraction operators for
        the <code><i>is</i></code> input stream type. Repeat this
        option to specify more than one stream type. The special
        <code><b>CDR</b></code> and <code><b>XDR</b></code> arguments
        are recognized as ACE CDR and Sun RPC XDR stream types and
        the corresponding stream wrappers provided by the XSD/e runtime
        are automatically used. For custom stream types use the
        <code><b>--hxx-prologue*</b></code> options to include the
        necessary declarations.</dd>

    <dt><code><b>--generate-forward</b></code></dt>
    <dd>Generate forward declaration file.</dd>

    <dt><code><b>--generate-xml-schema</b></code></dt>
    <dd>Generate C++ header files as if the schema being compiled defines
        the XML Schema namespace. In particular, the resulting files will
        have definitions for all object model types, parser skeletons and
        implementations, as well as serializer skeletons and implementations
        corresponding to the XML Schema built-in types. The schema file
        provided to the compiler need not exist and is only used to derive
        the names of the resulting header files. Use the
        <code><b>--extern-xml-schema</b></code> option to include these file
        in the generated files for other schemas.</dd>

    <dt><code><b>--extern-xml-schema</b> <i>file</i></code></dt>
    <dd>Include header files derived from <i>file</i> instead of
        generating the XML Schema namespace mapping inline. The provided
        file need not exist and is only used to derive the names of the
        included header files. Use the <code><b>--generate-xml-schema</b></code>
        option to generate these header files.</dd>

    <dt><code><b>--suppress-reset</b></code></dt>
    <dd>Suppress the generation of parser and serializer reset code.
        Reset support allows you to reuse parsers and serializers
        after an error.</dd>

    <dt><code><b>--generate-polymorphic</b></code></dt>
    <dd>Generate polymorphism-aware code. Specify this option if you use
        substitution groups or <code><b>xsi:type</b></code>. Use the
        <code><b>--polymorphic-type</b></code> option to specify which
        type hierarchies are polymorphic.</dd>

    <dt><code><b>--runtime-polymorphic</b></code></dt>
    <dd>Generate non-polymorphic code that uses the runtime library
        configured with polymorphism support.</dd>

    <dt><code><b>--polymorphic-type</b></code> <i>type</i></dt>
    <dd>Indicate that <code><i>type</i></code> is a root of a polymorphic
        type hierarchy. The compiler can often automatically determine
        which types are polymorphic based on the substitution group
        declarations. However, you may need to use this option if you are
        not using substitution groups or if substitution groups are defined
        in another schema. You need to specify this option when compiling
        every schema file that references <code><i>type</i></code>.</dd>

    <dt><code><b>--generate-typeinfo</b></code></dt>
    <dd>Generate custom type information querying functions for
        polymorphic object model types. These functions can be used
        instead of the standard C++ RTTI mechanism to determine
        object's type at runtime.</dd>

    <dt><code><b>--polymorphic-schema</b></code> <i>file</i></dt>
    <dd>Indicate that <code><i>file</i></code> contains derivations of
        polymorphic types that are not otherwise visible from the schema
        being compiled. This option is used to make sure that during the
        generation of parser and serializer aggregates the compiler is
        aware of all possible derivations of polymorphic types. Repeat
        this option to specify more than one schema file.</dd>

    <dt><code><b>--reuse-style-mixin</b></code></dt>
    <dd>Generate code that supports the mixin base parser/serializer
        implementation reuse style. Note that this reuse style
        relies on virtual inheritance and may result in a substantial
        object code size increase for large vocabularies. By default
        the tiein reuse style is used.</dd>

    <dt><code><b>--custom-data</b></code> <i>type</i></dt>
    <dd>Add the ability to store custom data to the C++ class generated
        for XML Schema type <code><i>type</i></code>. To add custom
        data to a nested compositor class use the qualified name
        starting from the XML Schema type containing the compositor,
        for example, <code><b>foo::sequence::choise1</b></code>.</dd>

    <dt><code><b>--custom-type</b>
    <i>name</i>[<b>=</b>[<i>flags</i>][<b>/</b>[<i>type</i>][<b>/</b>[<i>base</i>][<b>/</b><i>include</i>]]]]</code></dt>
    <dd>Use a custom type implementation instead of the generated version.
        The <code><i>name</i></code> component is the XML Schema type name
        being customized. Optional <code><i>flags</i></code> allow you to
        specify whether the custom type is fixed or variable-length. The
        <code><b>f</b></code> flag indicates the type is fixed-length and
        the <code><b>v</b></code> flag indicates the type is variable-length.
        If omitted, the default rules are used to determine the type length.
        Optional <code><i>type</i></code> is a C++ type name that should
        be used instead. If specified, the object model type is defined
        as a <code><b>typedef</b></code> alias for this C++ type. Optional
        <code><i>base</i></code> is a C++ name that should be given to the
        generated version. It is normally used as a base for the custom
        implementation. Optional <code><i>include</i></code> is the header
        file that defines the custom implementation. It is
        <code><b>#include</b></code>'ed into the generated code immediately
        after (if <code><i>base</i></code> is specified) or instead of the
        generated version.</dd>

    <dt><code><b>--custom-parser</b>
    <i>name</i>[<b>=</b>[<i>base</i>][<b>/</b><i>include</i>]]</code></dt>
    <dd>Use a custom parser implementation instead of the generated version.
        The <code><i>name</i></code> component is the XML Schema type name
        being customized. Optional <code><i>base</i></code> is a C++ name
        that should be given to the generated version. It is normally used
        as a base for the custom implementation. Optional
        <code><i>include</i></code> is the header file that defines the
        custom implementation. It is <code><b>#include</b></code>'ed
        into the generated code immediately after (if <code><i>base</i></code>
        is specified) or instead of the generated version.</dd>

    <dt><code><b>--custom-serializer</b>
    <i>name</i>[<b>=</b>[<i>base</i>][<b>/</b><i>include</i>]]</code></dt>
    <dd>Use a custom serializer implementation instead of the generated version.
        The <code><i>name</i></code> component is the XML Schema type name
        being customized. Optional <code><i>base</i></code> is a C++ name
        that should be given to the generated version. It is normally used
        as a base for the custom implementation. Optional
        <code><i>include</i></code> is the header file that defines the
        custom implementation. It is <code><b>#include</b></code>'ed
        into the generated code immediately after (if <code><i>base</i></code>
        is specified) or instead of the generated version.</dd>

    <!-- Root element/type. -->

    <dt><code><b>--root-element-first</b></code></dt>
    <dd>Treat only the first global element as a document root. This
        determines for which elements parser and serializer aggregates
        are generated. By default all global elements are considered
        document roots. See also the <code><b>--generate-aggregate</b></code>
        option.
    </dd>

    <dt><code><b>--root-element-last</b></code></dt>
    <dd>Treat only the last global element as a document root. This
        determines for which elements parser and serializer aggregates
        are generated. By default all global elements are considered
        document roots. See also the <code><b>--generate-aggregate</b></code>
        option.
    </dd>

    <dt><code><b>--root-element-all</b></code></dt>
    <dd>Treat all global elements as document roots (the default
        behavior). This determines for which elements parser and
        serializer aggregates are generated. By explicitly specifying
        this option you can suppress the warning that is issued if
        more than one global element is defined. See also the
        <code><b>--generate-aggregate</b></code> option.
    </dd>

    <dt><code><b>--root-element-none</b></code></dt>
    <dd>Do not treat any global elements as document roots. This
        determines for which elements parser and serializer aggregates
        are generated. By default all global elements are considered
        document roots. See also the <code><b>--generate-aggregate</b></code>
        option.
    </dd>

    <dt><code><b>--root-element</b> <i>element</i></code></dt>
    <dd>Treat only <code><i>element</i></code> as a document root. This
        determines for which elements parser and serializer aggregates
        are generated. Repeat this option to specify more than one root
        element. See also the <code><b>--generate-aggregate</b></code> option.
    </dd>

    <dt><code><b>--root-type</b> <i>type</i></code></dt>
    <dd>Generate parser/serializer aggregate for <code><i>type</i></code>.
        Repeat this option to specify more than one type. See also the
        <code><b>--generate-aggregate</b></code> option.</dd>

    <dt><code><b>--pskel-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>_pskel</b></code> to construct the names of generated parser
        skeletons.</dd>

    <dt><code><b>--sskel-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>_sskel</b></code> to construct the names of generated
        serializer skeletons.</dd>

    <dt><code><b>--pskel-file-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>-pskel</b></code> to construct the names of generated
        parser skeleton files.</dd>

    <dt><code><b>--sskel-file-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>-sskel</b></code> to construct the names of generated
        serializer skeleton files.</dd>

    <dt><code><b>--pimpl-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>_pimpl</b></code> to construct the names of generated
        parser implementations.</dd>

    <dt><code><b>--simpl-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>_simpl</b></code> to construct the names of generated
        serializer implementations.</dd>

    <dt><code><b>--pimpl-file-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>-pimpl</b></code> to construct the names of generated
        parser implementation files.</dd>

    <dt><code><b>--simpl-file-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>-simpl</b></code> to construct the names of generated
        serializer implementation files.</dd>

    <dt><code><b>--paggr-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>_paggs</b></code> to construct the names of generated
        parser aggregates.</dd>

    <dt><code><b>--saggr-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use <code><i>suffix</i></code> instead of the default
        <code><b>_saggr</b></code> to construct the names of generated
        serializer aggregates.</dd>
  </dl>

  <h2>CXX-PARSER COMMAND OPTIONS</h2>

  <dl class="options">
    <dt><code><b>--type-map</b> <i>mapfile</i></code></dt>
    <dd>Read XML Schema to C++ type mapping information from
        <code><i>mapfile</i></code>. Repeat this option to specify
        several type maps. Type maps are considered in order of
        appearance and the first match is used. By default all
        user-defined types are mapped to <code><b>void</b></code>.
        See the TYPE MAP section below for more information.</dd>

    <dt><code><b>--reuse-style-mixin</b></code></dt>
    <dd>Generate code that supports the mixin base parser
        implementation reuse style. Note that this reuse style
        relies on virtual inheritance and may result in a substantial
        object code size increase for large vocabularies. By default
        support for the tiein style is generated.</dd>

    <dt><code><b>--reuse-style-none</b></code></dt>
    <dd>Do not generate any support for base parser implementation
        reuse. By default support for the tiein style is generated.</dd>

    <dt><code><b>--suppress-validation</b></code></dt>
    <dd>Suppress the generation of validation code.</dd>

    <dt><code><b>--generate-polymorphic</b></code></dt>
    <dd>Generate polymorphism-aware code. Specify this option if you use
        substitution groups or <code><b>xsi:type</b></code>.</dd>

    <dt><code><b>--runtime-polymorphic</b></code></dt>
    <dd>Generate non-polymorphic code that uses the runtime library
        configured with polymorphism support.</dd>

    <dt><code><b>--suppress-reset</b></code></dt>
    <dd>Suppress the generation of parser reset code. Reset
        support allows you to reuse parsers after an error.</dd>

    <dt><code><b>--generate-noop-impl</b></code></dt>
    <dd>Generate a sample parser implementation that does nothing (no
        operation). The sample implementation can then be filled with
        the application-specific code. For an input file in the form
        <code><b>name.xsd</b></code> this option triggers the generation
        of the two additional C++ files in the form:
        <code><b>name-pimpl.hxx</b></code> (parser implementation header
        file) and <code><b>name-pimpl.cxx</b></code> (parser implementation
        source file).</dd>

    <dt><code><b>--generate-print-impl</b></code></dt>
    <dd>Generate a sample parser implementation that prints the XML data
        to STDOUT. For an input file in the form <code><b>name.xsd</b></code>
        this option triggers the generation of the two additional C++ files
        in the form: <code><b>name-pimpl.hxx</b></code> (parser implementation
        header file) and <code><b>name-pimpl.cxx</b></code> (parser
        implementation source file).</dd>

    <dt><code><b>--generate-test-driver</b></code></dt>
    <dd>Generate a test driver for the sample parser implementation. For an
        input file in the form <code><b>name.xsd</b></code> this option
        triggers the generation of an additional C++ file in the form
        <code><b>name-pdriver.cxx</b></code>.</dd>

    <dt><code><b>--force-overwrite</b></code></dt>
    <dd>Force overwriting of the existing implementation and test driver
        files. Use this option only if you do not mind loosing the changes
        you have made in the sample implementation or test driver files.</dd>

    <dt><code><b>--root-element-first</b></code></dt>
    <dd>Indicate that the first global element is the document root. This
        information is used to generate the test driver for the sample
        implementation.</dd>

    <dt><code><b>--root-element-last</b></code></dt>
    <dd>Indicate that the last global element is the document root. This
        information is used to generate the test driver for the sample
        implementation.</dd>

    <dt><code><b>--root-element <i>element</i></b></code></dt>
    <dd>Indicate that <code><i>element</i></code> is the document root.
        This information is used to generate the test driver for the
        sample implementation.</dd>

    <dt><code><b>--generate-xml-schema</b></code></dt>
    <dd>Generate a C++ header file as if the schema being compiled defines
        the XML Schema namespace. In particular, the resulting file will
        have definitions for all parser skeletons and implementations
        corresponding to the XML Schema built-in types. The schema file
        provided to the compiler need not exist and is only used to derive
        the name of the resulting header file. Use the
        <code><b>--extern-xml-schema</b></code> option to include this file
        in the generated files for other schemas.</dd>

    <dt><code><b>--extern-xml-schema</b> <i>file</i></code></dt>
    <dd>Include a header file derived from <i>file</i> instead of
        generating the XML Schema namespace mapping inline. The provided
        file need not exist and is only used to derive the name of the
        included header file. Use the <code><b>--generate-xml-schema</b></code>
        option to generate this header file.</dd>

    <dt><code><b>--skel-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the
        default <code><b>_pskel</b></code> to construct the names
        of generated parser skeletons.</dd>

    <dt><code><b>--skel-file-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the
        default <code><b>-pskel</b></code> to construct the names of
        generated parser skeleton files.</dd>

    <dt><code><b>--impl-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the
        default <code><b>_pimpl</b></code> to construct the names of
        parser implementations for the built-in XML Schema types
        and sample parser implementations.</dd>

    <dt><code><b>--impl-file-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the
        default <code><b>-pimpl</b></code> to construct the names of
        generated sample parser implementation files.</dd>
  </dl>

  <h2>CXX-SERIALIZER COMMAND OPTIONS</h2>

  <dl class="options">
    <dt><code><b>--type-map</b> <i>mapfile</i></code></dt>
    <dd>Read XML Schema to C++ type mapping information from
        <code><i>mapfile</i></code>. Repeat this option to specify
        several type maps. Type maps are considered in order of
        appearance and the first match is used. By default all
        user-defined types are mapped to <code><b>void</b></code>.
        See the TYPE MAP section below for more information.</dd>

    <dt><code><b>--reuse-style-mixin</b></code></dt>
    <dd>Generate code that supports the mixin base serializer
        implementation reuse style. Note that this reuse style
        relies on virtual inheritance and may result in a substantial
        object code size increase for large vocabularies. By default
        support for the tiein style is generated.</dd>

    <dt><code><b>--reuse-style-none</b></code></dt>
    <dd>Do not generate any support for base serializer implementation
        reuse. By default support for the tiein style is generated.</dd>

    <dt><code><b>--suppress-validation</b></code></dt>
    <dd>Suppress the generation of validation code.</dd>

    <dt><code><b>--generate-polymorphic</b></code></dt>
    <dd>Generate polymorphism-aware code. Specify this option if you use
        substitution groups or <code><b>xsi:type</b></code>.</dd>

    <dt><code><b>--runtime-polymorphic</b></code></dt>
    <dd>Generate non-polymorphic code that uses the runtime library
        configured with polymorphism support.</dd>

    <dt><code><b>--suppress-reset</b></code></dt>
    <dd>Suppress the generation of serializer reset code. Reset
        support allows you to reuse serializers after an error.</dd>

    <dt><code><b>--generate-empty-impl</b></code></dt>
    <dd>Generate a sample serializer implementation with empty function
        bodies which can then be filled with the application-specific code.
        For an input file in the form <code><b>name.xsd</b></code> this
        option triggers the generation of the two additional C++ files in the
        form: <code><b>name-simpl.hxx</b></code> (serializer implementation
        header file) and <code><b>name-simpl.cxx</b></code> (serializer
        implementation source file).</dd>

    <dt><code><b>--generate-test-driver</b></code></dt>
    <dd>Generate a test driver for the sample serializer implementation. For
        an input file in the form <code><b>name.xsd</b></code> this option
        triggers the generation of an additional C++ file in the form
        <code><b>name-sdriver.cxx</b></code>.</dd>

    <dt><code><b>--force-overwrite</b></code></dt>
    <dd>Force overwriting of the existing implementation and test driver
        files. Use this option only if you do not mind loosing the changes
        you have made in the sample implementation or test driver files.</dd>

    <dt><code><b>--root-element-first</b></code></dt>
    <dd>Indicate that the first global element is the document root. This
        information is used to generate the test driver for the sample
        implementation.</dd>

    <dt><code><b>--root-element-last</b></code></dt>
    <dd>Indicate that the last global element is the document root. This
        information is used to generate the test driver for the sample
        implementation.</dd>

    <dt><code><b>--root-element <i>element</i></b></code></dt>
    <dd>Indicate that <code><i>element</i></code> is the document root.
        This information is used to generate the test driver for the
        sample implementation.</dd>

    <dt><code><b>--generate-xml-schema</b></code></dt>
    <dd>Generate a C++ header file as if the schema being compiled defines
        the XML Schema namespace. In particular, the resulting file will
        have definitions for all serializer skeletons and implementations
        corresponding to the XML Schema built-in types. The schema file
        provided to the compiler need not exist and is only used to derive
        the name of the resulting header file. Use the
        <code><b>--extern-xml-schema</b></code> option to include this file
        in the generated files for other schemas.</dd>

    <dt><code><b>--extern-xml-schema</b> <i>file</i></code></dt>
    <dd>Include a header file derived from <i>file</i> instead of
        generating the XML Schema namespace mapping inline. The provided
        file need not exist and is only used to derive the name of the
        included header file. Use the <code><b>--generate-xml-schema</b></code>
        option to generate this header file.</dd>

    <dt><code><b>--skel-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the
        default <code><b>_sskel</b></code> to construct the names
        of generated serializer skeletons.</dd>

    <dt><code><b>--skel-file-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the
        default <code><b>-sskel</b></code> to construct the names of
        generated serializer skeleton files.</dd>

    <dt><code><b>--impl-type-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the
        default <code><b>_simpl</b></code> to construct the names of
        serializer implementations for the built-in XML Schema types
        and sample serializer implementations.</dd>

    <dt><code><b>--impl-file-suffix</b> <i>suffix</i></code></dt>
    <dd>Use the provided <code><i>suffix</i></code> instead of the
        default <code><b>-simpl</b></code> to construct the names of
        generated sample serializer implementation files.</dd>
  </dl>


  <h1>TYPE MAP</h1>

  <p>Type map files are used to define a mapping between XML Schema
     and C++ types. For C++/Parser, the compiler uses
     this information to determine the return types of
     <code><b>post_*</b></code> functions in parser skeletons
     corresponding to XML Schema types as well as argument types
     for callbacks corresponding to elements and attributes of these
     types. For C++/Serializer, type maps are used to determine
     the argument type of <code><b>pre</b></code> functions in
     serializer skeletons corresponding to XML Schema types as
     well as return types for callbacks corresponding to elements
     and attributes of these types.</p>

  <p>The compiler has a set of predefined mapping rules that map
     the built-in XML Schema types to suitable C++ types (discussed
     in the following sub-sections) and all other types to
     <code><b>void</b></code>. By providing your own type maps you
     can override these predefined rules. The format of the type map
     file is presented below:
  </p>

  <pre>
namespace &lt;schema-namespace> [&lt;cxx-namespace>]
{
  (include &lt;file-name>;)*
  ([type] &lt;schema-type> &lt;cxx-ret-type> [&lt;cxx-arg-type>];)*
}
  </pre>

  <p>Both <code><i>&lt;schema-namespace></i></code> and
     <code><i>&lt;schema-type></i></code> are regex patterns while
     <code><i>&lt;cxx-namespace></i></code>,
     <code><i>&lt;cxx-ret-type></i></code>, and
     <code><i>&lt;cxx-arg-type></i></code> are regex pattern
     substitutions. All names can be optionally enclosed in
     <code><b>"&nbsp;"</b></code>, for example, to include white-spaces.</p>

  <p><code><i>&lt;schema-namespace></i></code> determines XML
     Schema namespace. Optional <code><i>&lt;cxx-namespace></i></code>
     is prefixed to every C++ type name in this namespace declaration.
     <code><i>&lt;cxx-ret-type></i></code> is a C++ type name that is
     used as a return type for the <code><b>post_*</b></code> function
     in C++/Parser or for element/attribute callbacks in C++/Serializer.
     Optional <code><i>&lt;cxx-arg-type></i></code> is an argument type
     for element/attribute callbacks in C++/Parser or for the
     <code><b>pre</b></code> function in C++/Serializer. If
     <code><i>&lt;cxx-arg-type></i></code> is not specified, it defaults
     to <code><i>&lt;cxx-ret-type></i></code> if <code><i>&lt;cxx-ret-type></i></code>
     ends with <code><b>*</b></code> or <code><b>&amp;</b></code> (that is,
     it is a pointer or a reference) and
     <code><b>const</b>&nbsp;<i>&lt;cxx-ret-type></i><b>&amp;</b></code>
     otherwise.
     <code><i>&lt;file-name></i></code> is a file name either in the
     <code><b>"&nbsp;"</b></code> or <code><b>&lt;&nbsp;></b></code> format
     and is added with the <code><b>#include</b></code> directive to
     the generated code.</p>

  <p>The <code><b>#</b></code> character starts a comment that ends
     with a new line or end of file. To specify a name that contains
     <code><b>#</b></code> enclose it in <code><b>"&nbsp;"</b></code>.
     For example:</p>

  <pre>
namespace http://www.example.com/xmlns/my my
{
  include "my.hxx";

  # Pass apples by value.
  #
  apple apple;

  # Pass oranges as pointers.
  #
  orange orange_t*;
}
  </pre>

  <p>In the example above, for the
     <code><b>http://www.example.com/xmlns/my#orange</b></code>
     XML Schema type, the <code><b>my::orange_t*</b></code> C++ type will
     be used as both return and argument types.</p>

  <p>Several namespace declarations can be specified in a single
     file. The namespace declaration can also be completely
     omitted to map types in a schema without a namespace. For
     instance:</p>

  <pre>
include "my.hxx";
apple apple;

namespace http://www.example.com/xmlns/my
{
  orange "const orange_t*";
}
  </pre>

  <p>The compiler has a number of predefined mapping rules
     for the built-in XML Schema types that vary depending on
     the mapping used. They are described in the following
     subsections. The last predefined rule for all the mappings
     maps anything that wasn't mapped by previous rules to
     <code><b>void</b></code>:</p>

  <pre>
namespace .*
{
  .* void void;
}
  </pre>

  <p>When you provide your own type maps with the
     <code><b>--type-map</b></code> option, they are evaluated first.
     This allows you to selectively override predefined rules.</p>


  <h2>Predefined C++/Parser Type Maps</h2>

  <p>The C++/Parser mapping provides a number of predefined type
     map rules for the built-in XML Schema types. They can be
     presented as the following map files:</p>

  <pre>
namespace http://www.w3.org/2001/XMLSchema
{
  boolean bool bool;

  byte "signed char" "signed char";
  unsignedByte "unsigned char" "unsigned char";

  short short short;
  unsignedShort "unsigned short" "unsigned short";

  int int int;
  unsignedInt "unsigned int" "unsigned int";

  long "long long" "long long";
  unsignedLong "unsigned long long" "unsigned long long";

  integer long long;

  negativeInteger long long;
  nonPositiveInteger long long;

  positiveInteger "unsigned long" "unsigned long";
  nonNegativeInteger "unsigned long" "unsigned long";

  float float float;
  double double double;
  decimal double double;

  NMTOKENS xml_schema::string_sequence*;
  IDREFS xml_schema::string_sequence*;

  base64Binary xml_schema::buffer*;
  hexBinary xml_schema::buffer*;

  date xml_schema::date;
  dateTime xml_schema::date_time;
  duration xml_schema::duration;
  gDay xml_schema::gday;
  gMonth xml_schema::gmonth;
  gMonthDay xml_schema::gmonth_day;
  gYear xml_schema::gyear;
  gYearMonth xml_schema::gyear_month;
  time xml_schema::time;
}
  </pre>

  <p>If the <code><b>--no-stl</b></code> option is not specified,
     the following mapping is used for the string-based XML Schema
     built-in types:</p>

  <pre>
namespace http://www.w3.org/2001/XMLSchema
{
  include &lt;string>;

  string std::string;
  normalizedString std::string;
  token std::string;
  Name std::string;
  NMTOKEN std::string;
  NCName std::string;
  ID std::string;
  IDREF std::string;
  language std::string;
  anyURI std::string;

  QName xml_schema::qname;
}
  </pre>

  <p>Otherwise, a C string-based mapping is used:</p>

  <pre>
namespace http://www.w3.org/2001/XMLSchema
{
  string char*;
  normalizedString char*;
  token char*;
  Name char*;
  NMTOKEN char*;
  NCName char*;
  ID char*;
  IDREF char*;
  language char*;
  anyURI char*;

  QName xml_schema::qname*;
}
  </pre>

  <h2>Predefined C++/Serializer Type Maps</h2>

  <p>The C++/Serializer mapping provides a number of predefined type
     map rules for the built-in XML Schema types. They can be
     presented as the following map files:</p>

  <pre>
namespace http://www.w3.org/2001/XMLSchema
{
  boolean bool bool;

  byte "signed char" "signed char";
  unsignedByte "unsigned char" "unsigned char";

  short short short;
  unsignedShort "unsigned short" "unsigned short";

  int int int;
  unsignedInt "unsigned int" "unsigned int";

  long "long long" "long long";
  unsignedLong "unsigned long long" "unsigned long long";

  integer long long;

  negativeInteger long long;
  nonPositiveInteger long long;

  positiveInteger "unsigned long" "unsigned long";
  nonNegativeInteger "unsigned long" "unsigned long";

  float float float;
  double double double;
  decimal double double;

  NMTOKENS "const xml_schema::string_sequence*";
  IDREFS "const xml_schema::string_sequence*";

  base64Binary "const xml_schema::buffer*";
  hexBinary "const xml_schema::buffer*";

  date xml_schema::date;
  dateTime xml_schema::date_time;
  duration xml_schema::duration;
  gDay xml_schema::gday;
  gMonth xml_schema::gmonth;
  gMonthDay xml_schema::gmonth_day;
  gYear xml_schema::gyear;
  gYearMonth xml_schema::gyear_month;
  time xml_schema::time;
}
  </pre>

  <p>If the <code><b>--no-stl</b></code> option is not specified,
     the following mapping is used for the string-based XML Schema
     built-in types:</p>

  <pre>
namespace http://www.w3.org/2001/XMLSchema
{
  include &lt;string>;

  string std::string;
  normalizedString std::string;
  token std::string;
  Name std::string;
  NMTOKEN std::string;
  NCName std::string;
  ID std::string;
  IDREF std::string;
  language std::string;
  anyURI std::string;

  QName xml_schema::qname;
}
  </pre>

  <p>Otherwise, a C string-based mapping is used:</p>

  <pre>
namespace http://www.w3.org/2001/XMLSchema
{
  string "const char*";
  normalizedString "const char*";
  token "const char*";
  Name "const char*";
  NMTOKEN "const char*";
  NCName "const char*";
  ID "const char*";
  IDREF "const char*";
  language "const char*";
  anyURI "const char*";

  QName "const xml_schema::qname*";
}
  </pre>

  <h1>REGEX AND SHELL QUOTING</h1>

  <p>When entering a regular expression argument in the shell
     command line it is often necessary to use quoting (enclosing
     the argument in <code><b>"&nbsp;"</b></code> or
     <code><b>'&nbsp;'</b></code>) in order to prevent the shell
     from interpreting certain characters, for example, spaces as
     argument separators and <code><b>$</b></code> as variable
     expansions.</p>

  <p>Unfortunately it is hard to achieve this in a manner that is
     portable across POSIX shells, such as those found on
     GNU/Linux and UNIX, and Windows shell. For example, if you
     use <code><b>"&nbsp;"</b></code> for quoting you will get a
     wrong result with POSIX shells if your expression contains
     <code><b>$</b></code>. The standard way of dealing with this
     on POSIX systems is to use <code><b>'&nbsp;'</b></code> instead.
     Unfortunately, Windows shell does not remove <code><b>'&nbsp;'</b></code>
     from arguments when they are passed to applications. As a result you
     may have to use <code><b>'&nbsp;'</b></code> for POSIX and
     <code><b>"&nbsp;"</b></code> for Windows (<code><b>$</b></code> is
     not treated as a special character on Windows).</p>

  <p>Alternatively, you can save regular expression options into
     a file, one option per line, and use this file with the
     <code><b>--options-file</b></code> option. With this approach
     you don't need to worry about shell quoting.</p>

  <h1>DIAGNOSTICS</h1>

  <p>If the input file is not a valid W3C XML Schema definition,
    <code><b>xsde</b></code> will issue diagnostic messages to STDERR
    and exit with non-zero exit code.</p>

  <h1>BUGS</h1>

  <p>Send bug reports to the
     <a href="mailto:xsde-users@codesynthesis.com">xsde-users@codesynthesis.com</a> mailing list.</p>

  </div>
  <div id="footer">
    &copy;2005-2011 <a href="http://codesynthesis.com">CODE SYNTHESIS TOOLS CC</a>

    <div id="terms">
      Permission is granted to copy, distribute and/or modify this
      document under the terms of the
      <a href="http://codesynthesis.com/licenses/fdl-1.2.txt">GNU Free
      Documentation License, version 1.2</a>; with no Invariant Sections,
      no Front-Cover Texts and no Back-Cover Texts.
    </div>
  </div>
</div>
</body>
</html>
