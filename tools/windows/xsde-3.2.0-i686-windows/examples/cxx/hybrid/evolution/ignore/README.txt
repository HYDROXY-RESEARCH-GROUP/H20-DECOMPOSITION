This example shows how to handle schema evolution using substitution groups.
The general idea is as follows: the initial version of the schema defines
extension points using the XML Schema substitution group mechanism. The
subsequent versions of the schema add new elements to the substitution
groups. The goal here is for applications that were built using earlier
versions of the schema to be able to handle documents corresponding to the
newer versions without validation errors or any other failures. This example
shows how to ignore such new elements. The 'passthrough' example shows how
to pass the unknown content through parsing and serialization so that the
output XML contains all the unknown elements.

This example uses XML Schema polymorphism in the form of substitution groups.
If you are not familiar with how to work with polymorphic object models,
refer to the C++/Hybrid Mapping Getting Started Guide as well as the 
'polymorphism' example in the examples/cxx/hybrid/ directory.

The example consists of the following files:

transform.xsd
  The initial version of the schema that describes simple transformations,
  such as move and rotate. The schema makes it possible to add new
  transformations in subsequent versions of the schema. Our example is built
  using this schema.

transform-v2.xsd
  The second version of the schema which adds the scale transformation. This
  schema is provided as an example.

transform.xml
  Sample XML document corresponding to the second version of the schema. In
  particular, it contains the scale transformation which is unknown in
  transform.xsd.

transform.hxx
transform.cxx

transform-pskel.hxx
transform-pskel.cxx

transform-pimpl.hxx
transform-pimpl.cxx
  Object model (the first pair of files), parser skeletons (the second pair)
  and parser implementations (the third pair). These files are generated by
  the XSD/e compiler from transform.xsd. The --generate-parser and 
  --generate-aggregate options were used to request the generation of the
  parsing code. The --generate-polymorphic option was used to request the
  generation of the polymorphism-aware code.

driver.cxx
  Driver for the example. It first sets the substitution map callback that
  is used to tell the parser which elements should be ignored. The driver
  then calls the parser that constructs the object model from the input XML
  file. Finally, it prints the content of the object model to STDERR.

To run the example on the sample XML instance document simply execute:

$ ./driver transform.xml

The example reads from STDIN if input file is not specified:

$ ./driver <transform.xml
