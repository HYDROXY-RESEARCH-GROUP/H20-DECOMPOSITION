This example shows how to perform partially event-driven, partially in-
memory processing using the Embedded C++/Hybrid mapping. With partially
event-driven parsing and serialization we can process parts of the
document as they become available as well as handle documents that
are too large to fit into memory.

This example uses the parser and serializer customization mechanisms
provided by the C++/Hybrid mapping. For more information, see Section
4.8, "Customizing the Object Model" and Section 6.1, "Customizing
Parsers and Serializers" in the Embedded C++/Hybrid Mapping Getting
Started Guide.

The example consists of the following files:

position.xsd
  XML Schema which describes a simple object position vocabulary.
  The position is represented as a potentially large series of
  latitude/longitude measurements.

position.xml
  Sample object position document.

position.hxx
position.cxx

position-pskel.hxx
position-pskel.cxx
position-pimpl.hxx
position-pimpl.cxx

position-pskel.hxx
position-pskel.cxx
position-pimpl.hxx
position-pimpl.cxx
  Object model (the first pair of files), parser skeletons (the
  second pair), parser implementations (the third pair), serializer
  skeletons (the fourth pair), and serializer implementations (the
  fifth pair). These files are generated by the XSD/e compiler from
  position.xsd. The --generate-parser, --generate-serializer, and 
  --generate-aggregate options were used to request the generation
  of the parsing and serialization code. The --custom-parser option
  was used to customize the object_pimpl parser implementation. The 
  --custom-serializer option was used to customize the object_simpl
  serializer implementation.

object-pimpl.hxx
object-pimpl.cxx
  Custom object parser implementation. It calculates the average
  latitude and longitude values as position measurements become
  available. At the end it prints the object position based on
  these calculations. 

object-simpl.hxx
object-simpl.cxx
  Custom object serializer implementation. It performs a number of
  measurements of the object position and serializes them as they
  become available.

driver.cxx
  Driver for the example. It first calls the parser that calculates
  and prints the object position without constructing the object 
  model. It then serializes a new set of measurements which are
  taken as serialization progresses.

To run the example on the sample XML instance document simply execute:

$ ./driver position.xml

The example reads from STDIN if input file is not specified:

$ ./driver <position.xml
